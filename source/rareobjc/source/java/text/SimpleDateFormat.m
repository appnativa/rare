//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: mods/java/text/SimpleDateFormat.java
//
//  Created by decoteaud on 11/13/15.
//

#include "IOSClass.h"
#include "IOSObjectArray.h"
#include "java/lang/CloneNotSupportedException.h"
#include "java/lang/IllegalArgumentException.h"
#include "java/lang/Integer.h"
#include "java/lang/InternalError.h"
#include "java/lang/NullPointerException.h"
#include "java/lang/StringBuffer.h"
#include "java/text/AttributedCharacterIterator.h"
#include "java/text/AttributedString.h"
#include "java/text/DateFormat.h"
#include "java/text/DateFormatSymbols.h"
#include "java/text/FieldPosition.h"
#include "java/text/Format.h"
#include "java/text/NumberFormat.h"
#include "java/text/ParseException.h"
#include "java/text/ParsePosition.h"
#include "java/text/SimpleDateFormat.h"
#include "java/util/ArrayList.h"
#include "java/util/Calendar.h"
#include "java/util/Date.h"
#include "java/util/List.h"
#include "java/util/Locale.h"
#include "java/util/TimeZone.h"
#import "AppleHelper.h"
#import "APView+Component.h"

@implementation JavaTextSimpleDateFormat

static NSString * JavaTextSimpleDateFormat_PATTERN_CHARS_ = @"GyMdkHmsSEDFwWahKzZLc";

+ (NSString *)PATTERN_CHARS {
  return JavaTextSimpleDateFormat_PATTERN_CHARS_;
}

- (id)init {
  return [self initJavaTextSimpleDateFormatWithNSString:nil withJavaUtilLocale:[JavaUtilLocale getDefault]];
}

- (id)initWithNSString:(NSString *)pattern {
  return [self initJavaTextSimpleDateFormatWithNSString:pattern withJavaUtilLocale:[JavaUtilLocale getDefault]];
}

- (id)initWithNSString:(NSString *)template_
withJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *)symbols {
  if (self = [super init]) {
    pattern_ = template_;
    format__ = symbols;
    [self initialize__];
    if ((pattern_ != nil) && ([pattern_ length] > 0)) {
      [self applyPatternWithNSString:pattern_];
    }
  }
  return self;
}

- (id)initJavaTextSimpleDateFormatWithNSString:(NSString *)template_
                            withJavaUtilLocale:(JavaUtilLocale *)locale {
  if (self = [super init]) {
    pattern_ = template_;
    format__ = [[JavaTextDateFormatSymbols alloc] initWithJavaUtilLocale:locale];
    [self initialize__];
    if ((pattern_ != nil) && ([pattern_ length] > 0)) {
      [self applyPatternWithNSString:pattern_];
    }
  }
  return self;
}

- (id)initWithNSString:(NSString *)template_
    withJavaUtilLocale:(JavaUtilLocale *)locale {
  return [self initJavaTextSimpleDateFormatWithNSString:template_ withJavaUtilLocale:locale];
}

- (void)applyLocalizedPatternWithNSString:(NSString *)template_ {
  [((NSDateFormatter*)proxy_) setDateFormat:template_];
}

- (void)applyPatternWithNSString:(NSString *)template_ {
  [((NSDateFormatter*)proxy_) setDateFormat:template_];
}

- (id)clone {
  @try {
    return [[JavaTextSimpleDateFormat alloc] initWithNSString:pattern_ withJavaTextDateFormatSymbols:(JavaTextDateFormatSymbols *) check_class_cast([((JavaTextDateFormatSymbols *) nil_chk(format__)) clone], [JavaTextDateFormatSymbols class])];
  }
  @catch (JavaLangCloneNotSupportedException *ex) {
    @throw [[JavaLangInternalError alloc] initWithNSString:@"Cant clone"];
  }
}

- (JavaLangStringBuffer *)formatWithJavaUtilDate:(JavaUtilDate *)date
                        withJavaLangStringBuffer:(JavaLangStringBuffer *)toAppendTo
                       withJavaTextFieldPosition:(JavaTextFieldPosition *)fieldPosition {
  (void) [((JavaLangStringBuffer *) nil_chk(toAppendTo)) appendWithNSString:[self formatWithJavaUtilDate:date]];
  return toAppendTo;
}

- (void)initialize__ {
  proxy_ = ((JavaTextDateFormatSymbols *) nil_chk(format__))->proxy_;
}

- (JavaUtilDate *)parseWithNSString:(NSString *)source
          withJavaTextParsePosition:(JavaTextParsePosition *)pos {
  NSDate* date=[((NSDateFormatter*)proxy_) dateFromString:source];
  if(!date) {
    [pos setErrorIndexWithInt:(int)source.length];
    return nil;
  }
  [pos setIndexWithInt:(int)source.length];
  return [[JavaUtilDate alloc] initWithLong: (([date timeIntervalSince1970])*1000)];
}

- (id)parseObjectWithNSString:(NSString *)string {
  return [self parseWithNSString:string];
}

- (id)parseObjectWithNSString:(NSString *)source
    withJavaTextParsePosition:(JavaTextParsePosition *)pos {
  return [self parseWithNSString:source withJavaTextParsePosition:pos];
}

- (NSString *)toLocalizedPattern {
  return pattern_;
}

- (NSString *)toPattern {
  return pattern_;
}

- (id)getNSDateFormatter {
  return proxy_;
}

- (void)set2DigitYearStartWithJavaUtilDate:(JavaUtilDate *)startDate {
  [((NSDateFormatter*)proxy_) setTwoDigitStartDate:[NSDate fromJavaDate: startDate]];
}

- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorWithId:(id)object {
  if (object == nil) {
    @throw [[JavaLangNullPointerException alloc] initWithNSString:@"object == null"];
  }
  if ([object isKindOfClass:[JavaUtilDate class]]) {
    return [self formatToCharacterIteratorImplWithJavaUtilDate:(JavaUtilDate *) check_class_cast(object, [JavaUtilDate class])];
  }
  if ([object isKindOfClass:[NSNumber class]]) {
    return [self formatToCharacterIteratorImplWithJavaUtilDate:[[JavaUtilDate alloc] initWithLong:[((NSNumber *) check_class_cast(object, [NSNumber class])) longLongValue]]];
  }
  @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Bad class: %@", [nil_chk(object) getClass]]];
}

- (id<JavaTextAttributedCharacterIterator>)formatToCharacterIteratorImplWithJavaUtilDate:(JavaUtilDate *)date {
  JavaLangStringBuffer *buffer = [[JavaLangStringBuffer alloc] init];
  JavaUtilArrayList *fields = [[JavaUtilArrayList alloc] init];
  (void) [self formatImplWithJavaUtilDate:date withJavaLangStringBuffer:buffer withJavaTextFieldPosition:nil withJavaUtilList:fields];
  JavaTextAttributedString *as = [[JavaTextAttributedString alloc] initWithNSString:[buffer description]];
  for (JavaTextFieldPosition * __strong pos in fields) {
    JavaTextFormat_Field *attribute = [((JavaTextFieldPosition *) nil_chk(pos)) getFieldAttribute];
    [as addAttributeWithJavaTextAttributedCharacterIterator_Attribute:attribute withId:attribute withInt:[pos getBeginIndex] withInt:[pos getEndIndex]];
  }
  return [as getIterator];
}

- (JavaLangStringBuffer *)formatImplWithJavaUtilDate:(JavaUtilDate *)date
                            withJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                           withJavaTextFieldPosition:(JavaTextFieldPosition *)field
                                    withJavaUtilList:(id<JavaUtilList>)fields {
  BOOL quote = NO;
  int next, last = -1, count = 0;
  if ([self getCalendar] == nil) {
    [self setCalendarWithJavaUtilCalendar:[JavaUtilCalendar getInstance]];
  }
  if ([self getNumberFormat] == nil) {
    [self setNumberFormatWithJavaTextNumberFormat:[JavaTextNumberFormat getInstance]];
  }
  [((JavaUtilCalendar *) nil_chk([self getCalendar])) setTimeWithJavaUtilDate:date];
  if (field != nil) {
    [field setBeginIndexWithInt:0];
    [field setEndIndexWithInt:0];
  }
  int patternLength = (int)[((NSString *) nil_chk(pattern_)) length];
  for (int i = 0; i < patternLength; i++) {
    next = ([pattern_ charAtWithInt:i]);
    if (next == '\'') {
      if (count > 0) {
        [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        count = 0;
      }
      if (last == next) {
        (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:'\''];
        last = -1;
      }
      else {
        last = next;
      }
      quote = !quote;
      continue;
    }
    if (!quote && ((last == next) || ((next >= 'a') && (next <= 'z')) || ((next >= 'A') && (next <= 'Z')))) {
      if (last == next) {
        count++;
      }
      else {
        if (count > 0) {
          [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        }
        last = next;
        count = 1;
      }
    }
    else {
      if (count > 0) {
        [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
        count = 0;
      }
      last = -1;
      (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:(unichar) next];
    }
  }
  if (count > 0) {
    [self appendWithJavaLangStringBuffer:buffer withJavaTextFieldPosition:field withJavaUtilList:fields withChar:(unichar) last withInt:count];
  }
  return buffer;
}

- (void)appendWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
             withJavaTextFieldPosition:(JavaTextFieldPosition *)position
                      withJavaUtilList:(id<JavaUtilList>)fields
                              withChar:(unichar)format
                               withInt:(int)count {
  int field = -1;
  int index = [((NSString *) nil_chk(JavaTextSimpleDateFormat_PATTERN_CHARS_)) indexOf:format];
  if (index == -1) {
    @throw [[JavaLangIllegalArgumentException alloc] initWithNSString:[NSString stringWithFormat:@"Unknown pattern character '%C'", format]];
  }
  int beginPosition = [((JavaLangStringBuffer *) nil_chk(buffer)) sequenceLength];
  JavaTextDateFormat_Field *dateFormatField = nil;
  {
    int year;
    int hour;
    int value;
    switch (index) {
      case JavaTextDateFormat_ERA_FIELD:
      dateFormatField = [JavaTextDateFormat_Field ERA];
      (void) [buffer appendWithNSString:IOSObjectArray_Get(nil_chk([((JavaTextDateFormatSymbols *) nil_chk(self->format__)) getEras]), [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_ERA])];
      break;
      case JavaTextDateFormat_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field YEAR];
      year = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_YEAR];
      if (count == 2) {
        [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:year % 100];
      }
      else {
        [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:year];
      }
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MONTH];
      [self appendMonthWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextDateFormat_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MONTH];
      [self appendMonthWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
      case JavaTextDateFormat_DATE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_MONTH];
      field = JavaUtilCalendar_DATE;
      break;
      case JavaTextDateFormat_HOUR_OF_DAY1_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR_OF_DAY1];
      hour = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_HOUR_OF_DAY];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:(hour == 0) ? 24 : hour];
      break;
      case JavaTextDateFormat_HOUR_OF_DAY0_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR_OF_DAY0];
      field = JavaUtilCalendar_HOUR_OF_DAY;
      break;
      case JavaTextDateFormat_MINUTE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MINUTE];
      field = JavaUtilCalendar_MINUTE;
      break;
      case JavaTextDateFormat_SECOND_FIELD:
      dateFormatField = [JavaTextDateFormat_Field SECOND];
      field = JavaUtilCalendar_SECOND;
      break;
      case JavaTextDateFormat_MILLISECOND_FIELD:
      dateFormatField = [JavaTextDateFormat_Field MILLISECOND];
      value = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_MILLISECOND];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:value];
      break;
      case JavaTextSimpleDateFormat_STAND_ALONE_DAY_OF_WEEK_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK];
      [self appendDayOfWeekWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextDateFormat_DAY_OF_WEEK_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK];
      [self appendDayOfWeekWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
      case JavaTextDateFormat_DAY_OF_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_YEAR];
      field = JavaUtilCalendar_DAY_OF_YEAR;
      break;
      case JavaTextDateFormat_DAY_OF_WEEK_IN_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field DAY_OF_WEEK_IN_MONTH];
      field = JavaUtilCalendar_DAY_OF_WEEK_IN_MONTH;
      break;
      case JavaTextDateFormat_WEEK_OF_YEAR_FIELD:
      dateFormatField = [JavaTextDateFormat_Field WEEK_OF_YEAR];
      field = JavaUtilCalendar_WEEK_OF_YEAR;
      break;
      case JavaTextDateFormat_WEEK_OF_MONTH_FIELD:
      dateFormatField = [JavaTextDateFormat_Field WEEK_OF_MONTH];
      field = JavaUtilCalendar_WEEK_OF_MONTH;
      break;
      case JavaTextDateFormat_AM_PM_FIELD:
      dateFormatField = [JavaTextDateFormat_Field AM_PM];
      (void) [buffer appendWithNSString:IOSObjectArray_Get(nil_chk([((JavaTextDateFormatSymbols *) nil_chk(self->format__)) getAmPmStrings]), [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_AM_PM])];
      break;
      case JavaTextDateFormat_HOUR1_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR1];
      hour = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_HOUR];
      [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:(hour == 0) ? 12 : hour];
      break;
      case JavaTextDateFormat_HOUR0_FIELD:
      dateFormatField = [JavaTextDateFormat_Field HOUR0];
      field = JavaUtilCalendar_HOUR;
      break;
      case JavaTextDateFormat_TIMEZONE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field TIME_ZONE];
      [self appendTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:YES];
      break;
      case JavaTextSimpleDateFormat_RFC_822_TIMEZONE_FIELD:
      dateFormatField = [JavaTextDateFormat_Field TIME_ZONE];
      [self appendNumericTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:NO];
      break;
    }
  }
  if (field != -1) {
    [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:[((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:field]];
  }
  if (fields != nil) {
    position = [[JavaTextFieldPosition alloc] initWithJavaTextFormat_Field:dateFormatField];
    [position setBeginIndexWithInt:beginPosition];
    [position setEndIndexWithInt:[buffer sequenceLength]];
    [fields addWithId:position];
  }
  else {
    if ((([((JavaTextFieldPosition *) nil_chk(position)) getFieldAttribute] == dateFormatField) || (([position getFieldAttribute] == nil) && ([position getField] == index))) && ([position getEndIndex] == 0)) {
      [position setBeginIndexWithInt:beginPosition];
      [position setEndIndexWithInt:[buffer sequenceLength]];
    }
  }
}

- (void)appendDayOfWeekWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                        withInt:(int)count
                                    withBoolean:(BOOL)standAlone {
  IOSObjectArray *days;
  if (count == 4) {
    days = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getWeekdays];
  }
  else if (count == 5) {
    days = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getShortWeekdays];
  }
  else {
    days = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getShortWeekdays];
  }
  (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:IOSObjectArray_Get(nil_chk(days), [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_DAY_OF_WEEK])];
}

- (void)appendMonthWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                    withInt:(int)count
                                withBoolean:(BOOL)standAlone {
  int month = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_MONTH];
  if (count <= 2) {
    [self appendNumberWithJavaLangStringBuffer:buffer withInt:count withInt:month + 1];
    return;
  }
  IOSObjectArray *months;
  if (count == 4) {
    months = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getMonths];
  }
  else if (count == 5) {
    months = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getShortMonths];
  }
  else {
    months = [((JavaTextDateFormatSymbols *) nil_chk(format__)) getShortMonths];
  }
  (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:IOSObjectArray_Get(nil_chk(months), month)];
}

- (void)appendTimeZoneWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                       withInt:(int)count
                                   withBoolean:(BOOL)generalTimeZone {
  if (generalTimeZone) {
    JavaUtilTimeZone *tz = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getTimeZone];
    BOOL daylight = ([((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_DST_OFFSET] != 0);
    int style = (count < 4) ? JavaUtilTimeZone_SHORT : JavaUtilTimeZone_LONG;
    (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:[((JavaUtilTimeZone *) nil_chk(tz)) getDisplayNameWithBoolean:daylight withInt:style withJavaUtilLocale:((JavaTextDateFormatSymbols *) nil_chk(format__))->locale_]];
    return;
  }
  [self appendNumericTimeZoneWithJavaLangStringBuffer:buffer withInt:count withBoolean:generalTimeZone];
}

- (void)appendNumericTimeZoneWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                              withInt:(int)count
                                          withBoolean:(BOOL)generalTimeZone {
  int offset = [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_ZONE_OFFSET] + [((JavaUtilCalendar *) nil_chk([self getCalendar])) getWithInt:JavaUtilCalendar_DST_OFFSET];
  unichar sign = '+';
  if (offset < 0) {
    sign = '-';
    offset = -offset;
  }
  if (generalTimeZone || (count == 4)) {
    (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithNSString:@"GMT"];
  }
  (void) [((JavaLangStringBuffer *) nil_chk(buffer)) appendWithChar:sign];
  [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:offset / 3600000];
  if (generalTimeZone || (count >= 4)) {
    (void) [buffer appendWithChar:':'];
  }
  [self appendNumberWithJavaLangStringBuffer:buffer withInt:2 withInt:(offset % 3600000) / 60000];
}

- (void)appendNumberWithJavaLangStringBuffer:(JavaLangStringBuffer *)buffer
                                     withInt:(int)count
                                     withInt:(int)value {
  int minimumIntegerDigits = [((JavaTextNumberFormat *) nil_chk([self getNumberFormat])) getMinimumIntegerDigits];
  [((JavaTextNumberFormat *) nil_chk([self getNumberFormat])) setMinimumIntegerDigitsWithInt:count];
  (void) [((JavaTextNumberFormat *) nil_chk([self getNumberFormat])) formatWithId:[JavaLangInteger valueOfWithInt:value] withJavaLangStringBuffer:buffer withJavaTextFieldPosition:[[JavaTextFieldPosition alloc] initWithInt:0]];
  [((JavaTextNumberFormat *) nil_chk([self getNumberFormat])) setMinimumIntegerDigitsWithInt:minimumIntegerDigits];
}

- (JavaUtilDate *)errorWithJavaTextParsePosition:(JavaTextParsePosition *)position
                                         withInt:(int)offset
                            withJavaUtilTimeZone:(JavaUtilTimeZone *)zone {
  [((JavaTextParsePosition *) nil_chk(position)) setErrorIndexWithInt:offset];
  [((JavaUtilCalendar *) nil_chk([self getCalendar])) setTimeZoneWithJavaUtilTimeZone:zone];
  return nil;
}

- (JavaUtilCalendar *)getCalendar {
  if (calendar_ == nil) {
    JavaUtilTimeZone *tz = [self getTimeZone];
    calendar_ = [JavaUtilCalendar getInstanceWithJavaUtilTimeZone:tz != nil ? tz : [JavaUtilTimeZone getDefault] withJavaUtilLocale:((JavaTextDateFormatSymbols *) nil_chk(format__))->locale_];
  }
  return calendar_;
}

- (void)setCalendarWithJavaUtilCalendar:(JavaUtilCalendar *)calendar {
  self->calendar_ = calendar;
}

- (JavaTextNumberFormat *)getNumberFormat {
  if (numberFormat_ == nil) {
    numberFormat_ = [JavaTextNumberFormat getInstanceWithJavaUtilLocale:((JavaTextDateFormatSymbols *) nil_chk(format__))->locale_];
    [((JavaTextNumberFormat *) nil_chk(numberFormat_)) setGroupingUsedWithBoolean:NO];
  }
  return numberFormat_;
}

- (void)setNumberFormatWithJavaTextNumberFormat:(JavaTextNumberFormat *)numberFormat {
  self->numberFormat_ = numberFormat;
}

- (void)copyAllFieldsTo:(JavaTextSimpleDateFormat *)other {
  [super copyAllFieldsTo:other];
  other->calendar_ = calendar_;
  other->format__ = format__;
  other->numberFormat_ = numberFormat_;
  other->pattern_ = pattern_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "applyLocalizedPatternWithNSString:", NULL, "V", 0x101, NULL },
    { "applyPatternWithNSString:", NULL, "V", 0x101, NULL },
    { "clone", NULL, "LNSObject", 0x1, NULL },
    { "formatWithJavaUtilDate:withJavaLangStringBuffer:withJavaTextFieldPosition:", NULL, "LJavaLangStringBuffer", 0x1, NULL },
    { "initialize__", NULL, "V", 0x2, NULL },
    { "parseWithNSString:withJavaTextParsePosition:", NULL, "LJavaUtilDate", 0x101, NULL },
    { "parseObjectWithNSString:", NULL, "LNSObject", 0x1, "JavaTextParseException" },
    { "parseObjectWithNSString:withJavaTextParsePosition:", NULL, "LNSObject", 0x1, NULL },
    { "toLocalizedPattern", NULL, "LNSString", 0x1, NULL },
    { "toPattern", NULL, "LNSString", 0x1, NULL },
    { "getNSDateFormatter", NULL, "LNSObject", 0x1, NULL },
    { "set2DigitYearStartWithJavaUtilDate:", NULL, "V", 0x101, NULL },
    { "formatToCharacterIteratorWithId:", NULL, "LJavaTextAttributedCharacterIterator", 0x1, NULL },
    { "formatToCharacterIteratorImplWithJavaUtilDate:", NULL, "LJavaTextAttributedCharacterIterator", 0x2, NULL },
    { "formatImplWithJavaUtilDate:withJavaLangStringBuffer:withJavaTextFieldPosition:withJavaUtilList:", NULL, "LJavaLangStringBuffer", 0x2, NULL },
    { "appendWithJavaLangStringBuffer:withJavaTextFieldPosition:withJavaUtilList:withChar:withInt:", NULL, "V", 0x2, NULL },
    { "appendDayOfWeekWithJavaLangStringBuffer:withInt:withBoolean:", NULL, "V", 0x2, NULL },
    { "appendMonthWithJavaLangStringBuffer:withInt:withBoolean:", NULL, "V", 0x2, NULL },
    { "appendTimeZoneWithJavaLangStringBuffer:withInt:withBoolean:", NULL, "V", 0x2, NULL },
    { "appendNumericTimeZoneWithJavaLangStringBuffer:withInt:withBoolean:", NULL, "V", 0x2, NULL },
    { "appendNumberWithJavaLangStringBuffer:withInt:withInt:", NULL, "V", 0x2, NULL },
    { "errorWithJavaTextParsePosition:withInt:withJavaUtilTimeZone:", NULL, "LJavaUtilDate", 0x2, NULL },
    { "getCalendar", NULL, "LJavaUtilCalendar", 0x1, NULL },
    { "getNumberFormat", NULL, "LJavaTextNumberFormat", 0x1, NULL },
  };
  static J2ObjcFieldInfo fields[] = {
    { "format__", "format", 0x4, "LJavaTextDateFormatSymbols" },
    { "pattern_", NULL, 0x4, "LNSString" },
    { "calendar_", NULL, 0x4, "LJavaUtilCalendar" },
    { "numberFormat_", NULL, 0x4, "LJavaTextNumberFormat" },
    { "PATTERN_CHARS_", NULL, 0x18, "LNSString" },
    { "RFC_822_TIMEZONE_FIELD_", NULL, 0x1a, "I" },
    { "STAND_ALONE_MONTH_FIELD_", NULL, 0x1a, "I" },
    { "STAND_ALONE_DAY_OF_WEEK_FIELD_", NULL, 0x1a, "I" },
  };
  static J2ObjcClassInfo _JavaTextSimpleDateFormat = { "SimpleDateFormat", "java.text", NULL, 0x1, 24, methods, 8, fields, 0, NULL};
  return &_JavaTextSimpleDateFormat;
}

@end
