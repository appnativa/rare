//
//  Generated by the J2ObjC translator.  DO NOT EDIT!
//  source: /Code/Dev/appNativa/source/rareobjc/../rare/core/com/appnativa/rare/net/MultipartInputStream.java
//
//  Created by decoteaud on 12/8/15.
//

#include "IOSByteArray.h"
#include "IOSClass.h"
#include "IOSIntArray.h"
#include "com/appnativa/rare/net/MultipartInputStream.h"
#include "java/io/IOException.h"
#include "java/io/InputStream.h"
#include "java/lang/IllegalStateException.h"
#include "java/lang/Math.h"
#include "java/lang/StringBuilder.h"
#include "java/lang/System.h"
#include "java/util/Arrays.h"

@implementation RAREMultipartInputStream

- (id)initWithJavaIoInputStream:(JavaIoInputStream *)inArg
                   withNSString:(NSString *)boundary
                    withBoolean:(BOOL)keepPreamble {
  if (self = [super init]) {
    buffer_ = [IOSByteArray arrayWithLength:4096];
    oneByte_ = [IOSByteArray arrayWithLength:1];
    shift_ = [IOSIntArray arrayWithLength:256];
    state_ = RAREMultipartInputStream_STATE_START;
    builder_ = [[JavaLangStringBuilder alloc] initWithInt:256];
    self->in_ = inArg;
    self->keepPreamble_ = keepPreamble;
    int boundaryLen = [((NSString *) nil_chk(boundary)) sequenceLength];
    int delimiterLen = boundaryLen + 4;
    delimiter_ = [IOSByteArray arrayWithLength:delimiterLen];
    (*IOSByteArray_GetRef(delimiter_, 0)) = 0x000d;
    (*IOSByteArray_GetRef(delimiter_, 1)) = 0x000a;
    (*IOSByteArray_GetRef(delimiter_, 2)) = '-';
    (*IOSByteArray_GetRef(delimiter_, 3)) = '-';
    for (int i = 0; i < boundaryLen; i++) {
      (*IOSByteArray_GetRef(delimiter_, 4 + i)) = (char) [boundary charAtWithInt:i];
    }
    [JavaUtilArrays fillWithIntArray:shift_ withInt:delimiterLen + 1];
    for (int i = 0; i < delimiterLen; i++) {
      (*IOSIntArray_GetRef(shift_, IOSByteArray_Get(delimiter_, i))) = delimiterLen - i;
    }
  }
  return self;
}

- (NSString *)getPreamble {
  return preamble_;
}

- (BOOL)nextHeader {
  if (state_ != RAREMultipartInputStream_STATE_HEADERS) {
    @throw [[JavaLangIllegalStateException alloc] init];
  }
  if (([self lookAheadWithInt:0] == 0x000d) && ([self lookAheadWithInt:1] == 0x000a)) {
    [self discardWithInt:2];
    headerName_ = nil;
    headerValue_ = nil;
    state_ = RAREMultipartInputStream_STATE_CONTENT;
    delimiterFound_ = NO;
    nonDelimiterBytes_ = 0;
    return NO;
  }
  else if ([self lookAheadWithInt:0] == 0x000a) {
    [self discardWithInt:1];
    headerName_ = nil;
    headerValue_ = nil;
    state_ = RAREMultipartInputStream_STATE_CONTENT;
    delimiterFound_ = NO;
    nonDelimiterBytes_ = 0;
    return NO;
  }
  else {
    int len = 0;
    while ([self lookAheadWithInt:len] != ':') {
      len++;
    }
    headerName_ = [self readAsciiWithInt:len];
    [self discardWithInt:1];
    while ([self lookAheadWithInt:0] == ' ') {
      [self discardWithInt:1];
    }
    len = 0;
    while (([self lookAheadWithInt:len] != 0x000d) || ([self lookAheadWithInt:len + 1] != 0x000a)) {
      len++;
    }
    headerValue_ = [self readAsciiWithInt:len];
    [self discardWithInt:([self lookAheadWithInt:0] == 0x000d) ? 2 : 1];
    return YES;
  }
}

- (BOOL)nextPart {
  int delimiterLen = (int) [((IOSByteArray *) nil_chk(delimiter_)) count];
  [self fillBufferWithInt:delimiterLen];
  if (state_ == RAREMultipartInputStream_STATE_START) {
    for (int i = 0; i < delimiterLen - 2; i++) {
      if (IOSByteArray_Get(nil_chk(buffer_), i) != IOSByteArray_Get(delimiter_, i + 2)) {
        state_ = RAREMultipartInputStream_STATE_PREAMBLE;
        break;
      }
    }
    if (state_ != RAREMultipartInputStream_STATE_PREAMBLE) {
      if ((IOSByteArray_Get(nil_chk(buffer_), delimiterLen - 2) == 0x000d) && (IOSByteArray_Get(buffer_, delimiterLen - 1) == 0x000a)) {
        [self discardWithInt:delimiterLen];
        state_ = RAREMultipartInputStream_STATE_HEADERS;
      }
      else {
        state_ = RAREMultipartInputStream_STATE_PREAMBLE;
      }
    }
    if (state_ == RAREMultipartInputStream_STATE_PREAMBLE) {
      JavaLangStringBuilder *sb = nil;
      do {
        [self searchDelimiter];
        if (keepPreamble_) {
          if (sb == nil) {
            sb = [[JavaLangStringBuilder alloc] initWithInt:256];
          }
          (void) [self readAsciiWithJavaLangStringBuilder:sb withInt:nonDelimiterBytes_];
        }
        else {
          [self discardWithInt:nonDelimiterBytes_];
        }
        nonDelimiterBytes_ = 0;
      }
      while (!delimiterFound_);
      if (sb != nil) {
        preamble_ = [sb description];
      }
      [self processDelimiter];
    }
  }
  else if ((state_ == RAREMultipartInputStream_STATE_CONTENT) && delimiterFound_ && (nonDelimiterBytes_ == 0)) {
    [self processDelimiter];
  }
  else {
    do {
      [self searchDelimiter];
      [self discardWithInt:nonDelimiterBytes_];
      nonDelimiterBytes_ = 0;
    }
    while (!delimiterFound_);
    [self processDelimiter];
  }
  return state_ == RAREMultipartInputStream_STATE_HEADERS;
}

- (int)read {
  int c = [self readWithByteArray:oneByte_ withInt:0 withInt:1];
  return (c < 1) ? c : IOSByteArray_Get(nil_chk(oneByte_), 0);
}

- (int)readWithByteArray:(IOSByteArray *)b
                 withInt:(int)off
                 withInt:(int)len {
  if (state_ != RAREMultipartInputStream_STATE_CONTENT) {
    @throw [[JavaLangIllegalStateException alloc] init];
  }
  if (delimiterFound_ && (nonDelimiterBytes_ == 0)) {
    return -1;
  }
  else {
    if (nonDelimiterBytes_ == 0) {
      [self searchDelimiter];
    }
    int c = [JavaLangMath minWithInt:nonDelimiterBytes_ withInt:len];
    int currentBufferPosition = bufferPosition_;
    int newBufferPosition = currentBufferPosition + c;
    int bufferSize = (int) [((IOSByteArray *) nil_chk(buffer_)) count];
    if (newBufferPosition > bufferSize) {
      newBufferPosition -= bufferSize;
      int c1 = bufferSize - currentBufferPosition;
      [JavaLangSystem arraycopyWithId:buffer_ withInt:currentBufferPosition withId:b withInt:off withInt:c1];
      [JavaLangSystem arraycopyWithId:buffer_ withInt:0 withId:b withInt:off + c1 withInt:c - c1];
    }
    else {
      [JavaLangSystem arraycopyWithId:buffer_ withInt:currentBufferPosition withId:b withInt:off withInt:c];
    }
    bufferPosition_ = newBufferPosition;
    bufferLen_ -= c;
    nonDelimiterBytes_ -= c;
    return c;
  }
}

- (NSString *)getHeaderName {
  return headerName_;
}

- (NSString *)getHeaderValue {
  return headerValue_;
}

- (void)discardWithInt:(int)bytes {
  bufferPosition_ = (bufferPosition_ + bytes) % (int) [((IOSByteArray *) nil_chk(buffer_)) count];
  bufferLen_ -= bytes;
}

- (void)fillBufferWithInt:(int)minLen {
  int bufferSize = (int) [((IOSByteArray *) nil_chk(buffer_)) count];
  while (bufferLen_ < minLen) {
    int off = (bufferPosition_ + bufferLen_) % bufferSize;
    int len = [JavaLangMath minWithInt:bufferSize - off withInt:bufferSize - bufferLen_];
    int read = [((JavaIoInputStream *) nil_chk(in_)) readWithByteArray:buffer_ withInt:off withInt:len];
    if (read == -1) {
      @throw [[JavaIoIOException alloc] initWithNSString:@"Unexpected end of stream"];
    }
    bufferLen_ += read;
  }
}

- (int)lookAheadWithInt:(int)delta {
  [self fillBufferWithInt:delta + 1];
  return IOSByteArray_Get(buffer_, (bufferPosition_ + delta) % (int) [((IOSByteArray *) nil_chk(buffer_)) count]) & (int) 0xFF;
}

- (void)processDelimiter {
  [self discardWithInt:(int) [((IOSByteArray *) nil_chk(delimiter_)) count]];
  if (([self lookAheadWithInt:0] == '-') && ([self lookAheadWithInt:1] == '-')) {
    [self discardWithInt:2];
    state_ = RAREMultipartInputStream_STATE_END;
  }
  else if (([self lookAheadWithInt:0] == 0x000d) && ([self lookAheadWithInt:1] == 0x000a)) {
    [self discardWithInt:2];
    state_ = RAREMultipartInputStream_STATE_HEADERS;
  }
  else {
    @throw [[JavaIoIOException alloc] initWithNSString:@"Unexpected characters after delimiter"];
  }
}

- (NSString *)readAsciiWithInt:(int)length {
  [((JavaLangStringBuilder *) nil_chk(builder_)) setLengthWithInt:0];
  (void) [self readAsciiWithJavaLangStringBuilder:builder_ withInt:length];
  return [builder_ description];
}

- (JavaLangStringBuilder *)readAsciiWithJavaLangStringBuilder:(JavaLangStringBuilder *)sb
                                                      withInt:(int)length {
  int bufferSize = (int) [((IOSByteArray *) nil_chk(buffer_)) count];
  int bufferPosition = self->bufferPosition_;
  [sb ensureCapacityWithInt:[((JavaLangStringBuilder *) nil_chk(sb)) sequenceLength] + length];
  for (int i = 0; i < length; i++) {
    (void) [sb appendWithChar:(unichar) IOSByteArray_Get(buffer_, bufferPosition)];
    bufferPosition++;
    if (bufferPosition > bufferSize) {
      bufferPosition = 0;
    }
  }
  self->bufferPosition_ = bufferPosition;
  bufferLen_ -= length;
  return sb;
}

- (void)searchDelimiter {
  IOSByteArray *delimiter = self->delimiter_;
  IOSByteArray *buffer = self->buffer_;
  int delimiterLength = (int) [((IOSByteArray *) nil_chk(delimiter)) count];
  [self fillBufferWithInt:delimiterLength];
  int bufferPosition = self->bufferPosition_;
  int bufferLen = self->bufferLen_;
  int bufferSize = (int) [((IOSByteArray *) nil_chk(buffer)) count];
  int nonDelimiterBytes = self->nonDelimiterBytes_;
  while (bufferLen >= nonDelimiterBytes + delimiterLength) {
    BOOL found = YES;
    int pos = bufferPosition + nonDelimiterBytes;
    for (int i = 0; i < delimiterLength; i++) {
      if (pos >= bufferSize) {
        pos -= bufferSize;
      }
      if (IOSByteArray_Get(buffer, pos) != IOSByteArray_Get(delimiter, i)) {
        found = NO;
        break;
      }
      pos++;
    }
    if (found) {
      delimiterFound_ = YES;
      break;
    }
    else {
      nonDelimiterBytes += IOSIntArray_Get(nil_chk(shift_), IOSByteArray_Get(buffer, (bufferPosition + nonDelimiterBytes + delimiterLength) % bufferSize) & (int) 0xFF);
    }
  }
  self->nonDelimiterBytes_ = nonDelimiterBytes;
}

- (void)copyAllFieldsTo:(RAREMultipartInputStream *)other {
  [super copyAllFieldsTo:other];
  other->buffer_ = buffer_;
  other->bufferLen_ = bufferLen_;
  other->bufferPosition_ = bufferPosition_;
  other->builder_ = builder_;
  other->delimiter_ = delimiter_;
  other->delimiterFound_ = delimiterFound_;
  other->headerName_ = headerName_;
  other->headerValue_ = headerValue_;
  other->in_ = in_;
  other->keepPreamble_ = keepPreamble_;
  other->nonDelimiterBytes_ = nonDelimiterBytes_;
  other->oneByte_ = oneByte_;
  other->preamble_ = preamble_;
  other->shift_ = shift_;
  other->state_ = state_;
}

+ (J2ObjcClassInfo *)__metadata {
  static J2ObjcMethodInfo methods[] = {
    { "getPreamble", NULL, "LNSString", 0x1, NULL },
    { "nextHeader", NULL, "Z", 0x1, "JavaIoIOException" },
    { "nextPart", NULL, "Z", 0x1, "JavaIoIOException" },
    { "read", NULL, "I", 0x1, "JavaIoIOException" },
    { "readWithByteArray:withInt:withInt:", NULL, "I", 0x1, "JavaIoIOException" },
    { "getHeaderName", NULL, "LNSString", 0x1, NULL },
    { "getHeaderValue", NULL, "LNSString", 0x1, NULL },
    { "discardWithInt:", NULL, "V", 0x2, NULL },
    { "fillBufferWithInt:", NULL, "V", 0x2, "JavaIoIOException" },
    { "lookAheadWithInt:", NULL, "I", 0x2, "JavaIoIOException" },
    { "processDelimiter", NULL, "V", 0x2, "JavaIoIOException" },
    { "readAsciiWithInt:", NULL, "LNSString", 0x2, NULL },
    { "readAsciiWithJavaLangStringBuilder:withInt:", NULL, "LJavaLangStringBuilder", 0x2, NULL },
    { "searchDelimiter", NULL, "V", 0x2, "JavaIoIOException" },
  };
  static J2ObjcFieldInfo fields[] = {
    { "STATE_CONTENT_", NULL, 0x1a, "I" },
    { "STATE_END_", NULL, 0x1a, "I" },
    { "STATE_HEADERS_", NULL, 0x1a, "I" },
    { "STATE_PREAMBLE_", NULL, 0x1a, "I" },
    { "STATE_START_", NULL, 0x1a, "I" },
    { "buffer_", NULL, 0x12, "LIOSByteArray" },
    { "oneByte_", NULL, 0x12, "LIOSByteArray" },
    { "shift_", NULL, 0x12, "LIOSIntArray" },
    { "builder_", NULL, 0x12, "LJavaLangStringBuilder" },
    { "delimiter_", NULL, 0x12, "LIOSByteArray" },
    { "in_", NULL, 0x12, "LJavaIoInputStream" },
    { "keepPreamble_", NULL, 0x12, "Z" },
  };
  static J2ObjcClassInfo _RAREMultipartInputStream = { "MultipartInputStream", "com.appnativa.rare.net", NULL, 0x1, 14, methods, 12, fields, 0, NULL};
  return &_RAREMultipartInputStream;
}

@end
